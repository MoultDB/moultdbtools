---
title: "Examples"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Examples}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

This vignette contains example use cases for `taxonbridge`:

## Table of contents

**1. Detecting ambiguity and inconsistencies**

**2. Annotating a custom taxonomy**

## 1. Detecting ambiguity and inconsistencies

The first example illustrates how to detect ambiguity and inconsistency in a merged taxonomy. Start by loading the 2000 row sample dataset that comes with `taxonbridge`:

```{r, include=TRUE, message=FALSE}
library(taxonbridge)
sample <- load_sample()
dim(sample)
```

Next, retrieve all rows that have lineage information in both the GBIF backbone and NCBI:

```{r, include=TRUE}
lineages <- get_lineages(sample)
```

Then validate the lineages by using the kingdom and family taxonomic ranks, and create a list of the resulting tibble(s). Note that phylum, class, and order may also be used. In this example, entries that failed validation are returned by setting `valid = FALSE`.

```{r, include= TRUE}
kingdom <- get_validity(lineages, rank = "kingdom", valid = FALSE)
family <- get_validity(lineages, rank = "family", valid = FALSE)
candidates <- list(kingdom, family)
```

Finally, detect candidate incongruencies (excluding those with uninomial scientific names):

```{r, include= TRUE}
get_inconsistencies(candidates, uninomials = FALSE)
```

Two binomial names exhibit incongruency. Upon reference to the literature and the individual entries it can be seen that: 

* *Attheya septentrionalis* is assigned to different families of the **problematica** order Chaetocerotales

* *Gordonia neofelifaecis* is a plant (family: Theaceae) in the GBIF but a bacterium in the NCBI (family: Gordoniaceae)

*Attheya septentrionalis* has the status "synonym" in the GBIF data:

```{r, include= TRUE}
lineages[lineages$canonicalName=="Attheya septentrionalis", "taxonomicStatus"]
```

Applying the `get_status()` function and rerunning the exercise leaves only *Gordonia neofelifaecis* as a binomial incongruency with biological provenance:

```{r, include= TRUE}
lineages <- get_status(get_lineages(sample), status = "accepted")
kingdom <- get_validity(lineages, rank = "kingdom", valid = FALSE)
family <- get_validity(lineages, rank = "family", valid = FALSE)
candidates <- list(kingdom, family)
get_inconsistencies(candidates, uninomials = FALSE)
```

## 2. Annotating a custom taxonomy

Again, start by loading the 2000 row sample dataset that comes with `taxonbridge`. Then apply the `get_taxa()` method to find all decapod crustaceans in the sample dataset: 

```{r, include=TRUE, message=FALSE}
library(taxonbridge)
sample <- load_sample()
decapoda <- get_taxa(sample, order = "decapoda")
```

The `decapoda` object will serve as your base taxonomy. Create a new object that only retains decapods known as swimming crabs:

```{r, include=TRUE, message=FALSE}
swimming_crabs <- get_taxa(sample, family = "portunidae")
```

Next annotate your base taxonomy with this colloquial name for the family Portunidae:

```{r, include=TRUE, message=FALSE}
decapoda <- annotate(decapoda, names = swimming_crabs$canonicalName, 
                     new_column = "Swimming_crabs", present = "1")
```

A new column by the name "Swimming_crabs" has been added to the base taxonomy:

```{r, include=TRUE, message=TRUE}
colnames(decapoda)
```

Since only the `present` parameter and not the `absent` parameter was passed to `annotate()`, all species that are not members of the Portunidae will be assigned `NA` by default in the `Swimming_crabs` column. Swimming crabs can therefore be retrieved from the base taxonomy with the following command:

```{r, include=TRUE, message=TRUE}
decapoda[!is.na(decapoda$Swimming_crabs),"canonicalName"]
```
